{"version":3,"sources":["../src/index.tsx","../src/use-controllable-state.ts","../src/context.ts","#style-inject:#style-inject","../src/style.css","../src/use-prevent-scroll.ts","../src/use-composed-refs.ts"],"sourcesContent":["'use client';\n\nimport * as DialogPrimitive from '@radix-ui/react-dialog';\nimport { useControllableState } from './use-controllable-state';\nimport { DrawerContext, useDrawerContext } from './context';\nimport React, { useEffect } from 'react';\nimport './style.css';\nimport { usePreventScroll } from './use-prevent-scroll';\nimport { useComposedRefs } from './use-composed-refs';\n\nconst TRANSITIONS = {\n  DURATION: 0.5,\n  EASE: [0.32, 0.72, 0, 1],\n};\n\nconst BORDER_RADIUS = 8;\n\nconst cache = new Map();\n\ninterface Style {\n  [key: string]: string;\n}\n\nfunction set(el?: Element | HTMLElement | null, styles?: Style, ignoreCache = false) {\n  if (!el || !(el instanceof HTMLElement) || !styles) return;\n  let originalStyles: Style = {};\n\n  Object.entries(styles).forEach(([key, value]: [string, string]) => {\n    if (key.startsWith('--')) {\n      el.style.setProperty(key, value);\n      return;\n    }\n\n    originalStyles[key] = (el.style as any)[key];\n    (el.style as any)[key] = value;\n  });\n\n  if (ignoreCache) return;\n  cache.set(el, originalStyles);\n}\n\nfunction reset(el: Element | HTMLElement | null, prop?: string) {\n  if (!el || !(el instanceof HTMLElement)) return;\n  let originalStyles = cache.get(el);\n\n  if (!originalStyles) {\n    (el.style as any) = {};\n    return;\n  }\n\n  if (prop) {\n    (el.style as any)[prop] = originalStyles[prop];\n  } else {\n    Object.entries(originalStyles).forEach(([key, value]) => {\n      (el.style as any)[key] = value;\n    });\n  }\n}\n\ninterface DialogProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  shouldScaleBackground?: boolean;\n  dismissible?: boolean;\n  fixedHeight?: boolean;\n}\n\nfunction Root({\n  open: openProp,\n  defaultOpen,\n  onOpenChange,\n  children,\n  shouldScaleBackground,\n  fixedHeight,\n  dismissible = true,\n}: DialogProps) {\n  const [isOpen = false, setIsOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [isDragging, setIsDragging] = React.useState(false);\n  const overlayRef = React.useRef<HTMLDivElement>(null);\n  const dragStartTime = React.useRef<Date | null>(null);\n  const dragEndTime = React.useRef<Date | null>(null);\n  const lastTimeDragPrevented = React.useRef<Date | null>(null);\n  const pointerStartY = React.useRef(0);\n  const drawerRef = React.useRef<HTMLDivElement>(null);\n  const initialViewportHeight = React.useRef(0);\n\n  usePreventScroll({\n    isDisabled: !isOpen || isDragging || fixedHeight,\n  });\n\n  function getScale() {\n    return (window.innerWidth - 26) / window.innerWidth;\n  }\n\n  function onPress(event: React.PointerEvent<HTMLDivElement>) {\n    if (!dismissible) return;\n    setIsDragging(true);\n    dragStartTime.current = new Date();\n\n    // Ensure we maintain correct pointer capture even when going outside of the drawer\n    (event.target as HTMLElement).setPointerCapture(event.pointerId);\n\n    pointerStartY.current = event.clientY;\n  }\n\n  function shouldDrag(el: EventTarget, isDraggingDown: boolean) {\n    let element = el as HTMLElement;\n    const date = new Date();\n    const highlightedText = window.getSelection().toString();\n\n    // Don't drag if there's highlighted text\n    if (highlightedText.length > 0) {\n      return false;\n    }\n\n    // Disallow dragging if drawer was scrolled within last second\n    if (lastTimeDragPrevented.current && date.getTime() - lastTimeDragPrevented.current.getTime() < 1000) {\n      lastTimeDragPrevented.current = new Date();\n      return false;\n    }\n\n    // Keep climbing up the DOM tree as long as there's a parent\n    while (element) {\n      // Check if the element is scrollable\n      if (element.scrollHeight > element.clientHeight) {\n        if (element.role === 'dialog' || element.getAttribute('vaul-drawer')) return true;\n\n        if (element.scrollTop > 0) {\n          lastTimeDragPrevented.current = new Date();\n\n          // The element is scrollable and not scrolled to the top, so don't drag\n          return false;\n        }\n\n        if (isDraggingDown && element !== document.body) {\n          lastTimeDragPrevented.current = new Date();\n          // Element is scrolled to the top, but we are dragging down so we should allow scrolling\n          return false;\n        }\n      }\n\n      // Move up to the parent element\n      element = element.parentNode as HTMLElement;\n    }\n\n    // No scrollable parents not scrolled to the top found, so drag\n    return true;\n  }\n\n  function onMove(event: React.PointerEvent<HTMLDivElement>) {\n    // We need to know how much of the drawer has been dragged in percentages so that we can transform background accordingly\n    if (isDragging) {\n      const draggedDistance = pointerStartY.current - event.clientY;\n      const isDraggingDown = draggedDistance > 0;\n\n      if (!shouldDrag(event.target, isDraggingDown)) return;\n\n      const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n\n      set(drawerRef.current, {\n        transition: 'none',\n      });\n\n      // Allow dragging upwards up to 40px\n      if (draggedDistance > 0) {\n        set(drawerRef.current, {\n          '--swipe-amount': `${Math.max(draggedDistance * -1, -40)}px`,\n        });\n        return;\n      }\n\n      // We need to capture last time when drag with scroll was triggered and have a timeout between\n      const absDraggedDistance = Math.abs(draggedDistance);\n      const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n\n      const percentageDragged = absDraggedDistance / drawerHeight;\n      const opacityValue = 1 - percentageDragged;\n\n      set(\n        overlayRef.current,\n        {\n          opacity: `${opacityValue}`,\n        },\n        true,\n      );\n\n      if (wrapper && overlayRef.current && shouldScaleBackground) {\n        // Calculate percentageDragged as a fraction (0 to 1)\n\n        const scaleValue = Math.min(getScale() + percentageDragged * (1 - getScale()), 1);\n        const borderRadiusValue = 8 - percentageDragged * 8;\n\n        const translateYValue = Math.max(0, 14 - percentageDragged * 14);\n\n        set(\n          wrapper,\n          {\n            borderRadius: `${borderRadiusValue}px`,\n            transform: `scale(${scaleValue}) translateY(${translateYValue}px)`,\n            transition: 'none',\n          },\n          true,\n        );\n      }\n\n      set(drawerRef.current, {\n        '--swipe-amount': `${absDraggedDistance}px`,\n      });\n    }\n  }\n\n  useEffect(() => {\n    initialViewportHeight.current = window.visualViewport.height;\n\n    function onVisualViewportChange() {\n      if (!drawerRef.current || fixedHeight) return;\n\n      const visualViewportHeight = window.visualViewport.height;\n      const diffFromInitial = initialViewportHeight.current - visualViewportHeight;\n      const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n      const offsetFromTop = drawerRef.current?.getBoundingClientRect().top;\n\n      if (drawerHeight > visualViewportHeight) {\n        drawerRef.current.style.height = `${visualViewportHeight - offsetFromTop}px`;\n      } else {\n        drawerRef.current.style.height = 'initial';\n      }\n\n      drawerRef.current.style.bottom = `${diffFromInitial}px`;\n    }\n\n    window.visualViewport.addEventListener('resize', onVisualViewportChange);\n    return () => window.visualViewport.removeEventListener('resize', onVisualViewportChange);\n  }, []);\n\n  function closeDrawer() {\n    if (!dismissible) return;\n    setIsOpen(false);\n    const drawerHeight = drawerRef.current?.getBoundingClientRect().height || 0;\n\n    if (drawerRef.current) {\n      const swipeAmount = getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2);\n\n      set(drawerRef.current, {\n        '--hide-from': `${Number(swipeAmount).toFixed()}px`,\n        '--hide-to': `${drawerHeight.toFixed()}px`,\n      });\n\n      const opacityValue = overlayRef.current?.style.opacity || 1;\n\n      set(overlayRef.current, {\n        '--opacity-from': `${opacityValue}`,\n      });\n    }\n  }\n\n  React.useEffect(() => {\n    if (!isOpen && shouldScaleBackground) {\n      // Can't use `onAnimationEnd` as the component will be unmounted by then\n      const id = setTimeout(() => {\n        reset(document.body);\n      }, 200);\n\n      return () => clearTimeout(id);\n    }\n  }, [isOpen]);\n\n  function resetDrawer() {\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n    const currentSwipeAmount = Number(\n      getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2),\n    );\n\n    set(drawerRef.current, {\n      '--swipe-amount': `${0}px`,\n      transition: `transform 500ms cubic-bezier(0.32, 0.72, 0, 1)`,\n    });\n\n    // Don't reset background if swiped upwards\n    if (shouldScaleBackground && currentSwipeAmount > 0 && isOpen) {\n      set(\n        wrapper,\n        {\n          borderRadius: `${BORDER_RADIUS}px`,\n          overflow: 'hidden',\n          transform: `scale(${getScale()}) translateY(calc(env(safe-area-inset-top) + 14px))`,\n          transformOrigin: 'top',\n          transitionProperty: 'transform, border-radius',\n          transitionDuration: `${TRANSITIONS.DURATION}s`,\n          transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n        },\n        true,\n      );\n    }\n  }\n\n  function onRelease(event: React.PointerEvent<HTMLDivElement>) {\n    setIsDragging(false);\n    dragEndTime.current = new Date();\n    const swipeAmount = drawerRef.current\n      ? getComputedStyle(drawerRef.current).getPropertyValue('--swipe-amount').slice(0, -2)\n      : null;\n\n    if (!shouldDrag(event.target, false) || !swipeAmount) return;\n\n    if (dragStartTime.current === null) return;\n\n    const y = event.clientY;\n\n    const timeTaken = dragEndTime.current.getTime() - dragStartTime.current.getTime();\n    const distMoved = pointerStartY.current - y;\n    const velocity = Math.abs(distMoved) / timeTaken;\n\n    // Moved upwards, don't do anything\n    if (distMoved > 0) {\n      resetDrawer();\n      return;\n    }\n\n    if (velocity > 0.4) {\n      closeDrawer();\n      return;\n    }\n\n    if (y > window.innerHeight * 0.75) {\n      closeDrawer();\n      return;\n    }\n\n    resetDrawer();\n  }\n\n  function onAnimationStart(e: React.AnimationEvent<HTMLDivElement>) {\n    const wrapper = document.querySelector('[vaul-drawer-wrapper]');\n\n    if (!wrapper || !shouldScaleBackground) return;\n\n    if (e.animationName === 'show-dialog') {\n      set(\n        document.body,\n        {\n          background: 'black',\n        },\n        true,\n      );\n\n      set(wrapper, {\n        borderRadius: `${BORDER_RADIUS}px`,\n        overflow: 'hidden',\n        transform: `scale(${getScale()}) translateY(calc(env(safe-area-inset-top) + 14px))`,\n        transformOrigin: 'top',\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      });\n    } else if (e.animationName === 'hide-dialog') {\n      // Exit\n      reset(wrapper, 'transform');\n      reset(wrapper, 'borderRadius');\n      set(wrapper, {\n        transitionProperty: 'transform, border-radius',\n        transitionDuration: `${TRANSITIONS.DURATION}s`,\n        transitionTimingFunction: `cubic-bezier(${TRANSITIONS.EASE.join(',')})`,\n      });\n    }\n  }\n\n  return (\n    <DialogPrimitive.Root\n      open={isOpen}\n      onOpenChange={(o) => {\n        setIsOpen(o);\n      }}\n    >\n      <DrawerContext.Provider\n        value={{\n          drawerRef,\n          overlayRef,\n          onAnimationStart,\n          onPress,\n          onRelease,\n          onMove,\n          dismissible,\n        }}\n      >\n        {children}\n      </DrawerContext.Provider>\n    </DialogPrimitive.Root>\n  );\n}\n\nconst Overlay = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>>(\n  function ({ children, ...rest }, ref) {\n    const { overlayRef, onRelease } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, overlayRef);\n\n    return <DialogPrimitive.Overlay onMouseUp={onRelease} ref={composedRef} vaul-overlay=\"\" {...rest} />;\n  },\n);\n\nconst Content = React.forwardRef<HTMLDivElement, React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>>(\n  function ({ children, onOpenAutoFocus, onPointerDownOutside, ...rest }, ref) {\n    const { drawerRef, onPress, onRelease, onAnimationStart, onMove, dismissible } = useDrawerContext();\n    const composedRef = useComposedRefs(ref, drawerRef);\n\n    return (\n      <DialogPrimitive.Content\n        onAnimationStart={onAnimationStart}\n        onPointerDown={onPress}\n        onPointerUp={onRelease}\n        onPointerMove={onMove}\n        onOpenAutoFocus={(e) => {\n          if (onOpenAutoFocus) {\n            onOpenAutoFocus(e);\n          } else {\n            e.preventDefault();\n          }\n        }}\n        onPointerDownOutside={(e) => {\n          if (!dismissible) {\n            e.preventDefault();\n          }\n\n          onPointerDownOutside?.(e);\n        }}\n        ref={composedRef}\n        {...rest}\n        vaul-drawer=\"\"\n      >\n        {children}\n      </DialogPrimitive.Content>\n    );\n  },\n);\nexport const Drawer = Object.assign(\n  {},\n  {\n    Root,\n    Content,\n    Overlay,\n    Trigger: DialogPrimitive.Trigger,\n    Portal: DialogPrimitive.Portal,\n    Close: DialogPrimitive.Close,\n    Title: DialogPrimitive.Title,\n    Description: DialogPrimitive.Description,\n  },\n);\n","// This code comes from https://github.com/radix-ui/primitives/blob/main/packages/react/use-controllable-state/src/useControllableState.tsx\n\nimport React from 'react';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  // https://github.com/facebook/react/issues/19240\n  return React.useMemo(() => ((...args) => callbackRef.current?.(...args)) as T, []);\n}\n\nfunction useUncontrolledState<T>({ defaultProp, onChange }: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\nexport function useControllableState<T>({ prop, defaultProp, onChange = () => {} }: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange],\n  );\n\n  return [value, setValue] as const;\n}\n","import React from 'react';\n\ninterface DrawerContextValue {\n  drawerRef: React.RefObject<HTMLDivElement>;\n  overlayRef: React.RefObject<HTMLDivElement>;\n  onAnimationStart: (event: React.AnimationEvent<HTMLDivElement>) => void;\n  onPress: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onRelease: (event: React.PointerEvent<HTMLDivElement>) => void;\n  onMove: (event: React.PointerEvent<HTMLDivElement>) => void;\n  dismissible: boolean;\n}\n\nexport const DrawerContext = React.createContext<DrawerContextValue>({\n  drawerRef: React.createRef(),\n  overlayRef: React.createRef(),\n  onAnimationStart: () => {},\n  onPress: () => {},\n  onRelease: () => {},\n  onMove: () => {},\n  dismissible: true,\n});\n\nexport const useDrawerContext = () => React.useContext(DrawerContext);\n","\n          export default function styleInject(css, { insertAt } = {}) {\n            if (!css || typeof document === 'undefined') return\n          \n            const head = document.head || document.getElementsByTagName('head')[0]\n            const style = document.createElement('style')\n            style.type = 'text/css'\n          \n            if (insertAt === 'top') {\n              if (head.firstChild) {\n                head.insertBefore(style, head.firstChild)\n              } else {\n                head.appendChild(style)\n              }\n            } else {\n              head.appendChild(style)\n            }\n          \n            if (style.styleSheet) {\n              style.styleSheet.cssText = css\n            } else {\n              style.appendChild(document.createTextNode(css))\n            }\n          }\n          ","import styleInject from '#style-inject';styleInject(\"[vaul-drawer]{transform:translateY(var(--swipe-amount));touch-action:none;animation:show-dialog .5s cubic-bezier(.32,.72,0,1)}[vaul-drawer]:after{content:\\\"\\\";position:absolute;top:100%;background:inherit;background-color:inherit;left:0;right:0;height:200%}[vaul-drawer][data-state=closed]{animation:hide-dialog .5s cubic-bezier(.32,.72,0,1) forwards}[vaul-overlay]{animation:show-overlay .5s cubic-bezier(.32,.72,0,1)}[vaul-overlay][data-state=closed]{animation:hide-overlay .5s cubic-bezier(.32,.72,0,1) forwards}@keyframes show-dialog{0%{transform:translateY(100%)}to{transform:translateY(0)}}@keyframes hide-dialog{0%{transform:translateY(var(--hide-from, 0))}to{transform:translateY(100%)}}@keyframes show-overlay{0%{opacity:0}to{opacity:1}}@keyframes hide-overlay{0%{opacity:var(--opacity-from, 1)}to{opacity:0}}@media (hover: hover) and (pointer: fine){[vaul-drawer]{user-select:none}}\\n\")","// This code comes from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\n\nimport { useLayoutEffect } from 'react';\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean;\n  focusCallback?: () => void;\n}\n\nfunction chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (let callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n\nfunction isMac(): boolean | undefined {\n  return testPlatform(/^Mac/);\n}\n\nfunction isIPhone(): boolean | undefined {\n  return testPlatform(/^iPhone/);\n}\n\nfunction isIPad(): boolean | undefined {\n  return (\n    testPlatform(/^iPad/) ||\n    // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n    (isMac() && navigator.maxTouchPoints > 1)\n  );\n}\n\nfunction isIOS(): boolean | undefined {\n  return isIPhone() || isIPad();\n}\n\nfunction testPlatform(re: RegExp): boolean | undefined {\n  return typeof window !== 'undefined' && window.navigator != null ? re.test(window.navigator.platform) : undefined;\n}\n\n// @ts-ignore\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nexport function isScrollable(node: Element): boolean {\n  let style = window.getComputedStyle(node);\n  return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n\nexport function getScrollParent(node: Element): Element {\n  if (isScrollable(node)) {\n    node = node.parentElement as HTMLElement;\n  }\n\n  while (node && !isScrollable(node)) {\n    node = node.parentElement as HTMLElement;\n  }\n\n  return node || document.scrollingElement || document.documentElement;\n}\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset',\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  let { isDisabled } = options;\n\n  useLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden'),\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element;\n  let lastY = 0;\n  let onTouchStart = (e: TouchEvent) => {\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(e.target as Element);\n    if (scrollable === document.documentElement && scrollable === document.body) {\n      return;\n    }\n\n    lastY = e.changedTouches[0].pageY;\n  };\n\n  let onTouchMove = (e: TouchEvent) => {\n    // Prevent scrolling the window.\n    if (!scrollable || scrollable === document.documentElement || scrollable === document.body) {\n      e.preventDefault();\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead. Unfortunately, this disables bounce scrolling when at\n    // the top but it's the best we can do.\n    let y = e.changedTouches[0].pageY;\n    let scrollTop = scrollable.scrollTop;\n    let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n\n    if (bottom === 0) {\n      return;\n    }\n\n    if ((scrollTop <= 0 && y > lastY) || (scrollTop >= bottom && y < lastY)) {\n      e.preventDefault();\n    }\n\n    lastY = y;\n  };\n\n  let onTouchEnd = (e: TouchEvent) => {\n    let target = e.target as HTMLElement;\n\n    // Apply this change if we're not already focused on the target element\n    if (willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n  };\n\n  let onFocus = (e: FocusEvent) => {\n    let target = e.target as HTMLElement;\n    if (willOpenKeyboard(target)) {\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. ðŸ¤·â€â™‚ï¸\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener('resize', () => scrollIntoView(target), { once: true });\n          }\n        }\n      });\n    }\n  };\n\n  let onWindowScroll = () => {\n    // Last resort. If the window scrolled, scroll it back to the top.\n    // It should always be at the top because the body will have a negative margin (see below).\n    window.scrollTo(0, 0);\n  };\n\n  // Record the original scroll position so we can restore it.\n  // Then apply a negative margin to the body to offset it by the scroll position. This will\n  // enable us to scroll the window to the top, which is required for the rest of this to work.\n  let scrollX = window.pageXOffset;\n  let scrollY = window.pageYOffset;\n\n  let restoreStyles = chain(\n    setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`),\n    setStyle(document.documentElement, 'overflow', 'hidden'),\n    setStyle(document.body, 'marginTop', `-${scrollY}px`),\n  );\n\n  // Scroll to the top. The negative margin on the body will make this appear the same.\n  window.scrollTo(0, 0);\n\n  let removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, { passive: false, capture: true }),\n    addEvent(document, 'touchmove', onTouchMove, { passive: false, capture: true }),\n    addEvent(document, 'touchend', onTouchEnd, { passive: false, capture: true }),\n    addEvent(document, 'focus', onFocus, true),\n    addEvent(window, 'scroll', onWindowScroll),\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreStyles();\n    removeEvents();\n    window.scrollTo(scrollX, scrollY);\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: HTMLElement, style: string, value: string) {\n  let cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: EventTarget,\n  event: K,\n  handler: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions,\n) {\n  // @ts-ignore\n  target.addEventListener(event, handler, options);\n\n  return () => {\n    // @ts-ignore\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  let root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    let scrollable = getScrollParent(target);\n    if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n      let scrollableTop = scrollable.getBoundingClientRect().top;\n      let targetTop = target.getBoundingClientRect().top;\n      const keyboardHeight = scrollable.getBoundingClientRect().bottom;\n\n      if (targetTop > keyboardHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    // @ts-ignore\n    target = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement && !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n","// This code comes from https://github.com/radix-ui/primitives/tree/main/packages/react/compose-refs\n\nimport * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"],"mappings":"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","names":["src_exports","__export","Drawer","__toCommonJS","DialogPrimitive","import_react","useCallbackRef","callback","callbackRef","React","args","_a","useUncontrolledState","defaultProp","onChange","uncontrolledState","value","prevValueRef","handleChange","useControllableState","prop","uncontrolledProp","setUncontrolledProp","isControlled","setValue","nextValue","import_react","DrawerContext","React","useDrawerContext","import_react","styleInject","css","insertAt","head","style","styleInject","import_react","chain","callbacks","args","callback","isMac","testPlatform","isIPhone","isIPad","isIOS","re","visualViewport","isScrollable","node","style","getScrollParent","nonTextInputTypes","preventScrollCount","restore","usePreventScroll","options","isDisabled","preventScrollMobileSafari","preventScrollStandard","setStyle","scrollable","lastY","onTouchStart","e","onTouchMove","y","scrollTop","bottom","onTouchEnd","target","willOpenKeyboard","onFocus","scrollIntoView","onWindowScroll","scrollX","scrollY","restoreStyles","removeEvents","addEvent","element","value","cur","event","handler","root","scrollableTop","targetTop","keyboardHeight","React","setRef","ref","value","composeRefs","refs","node","useComposedRefs","TRANSITIONS","BORDER_RADIUS","cache","set","el","styles","ignoreCache","originalStyles","key","value","reset","prop","Root","openProp","defaultOpen","onOpenChange","children","shouldScaleBackground","fixedHeight","dismissible","isOpen","setIsOpen","useControllableState","isDragging","setIsDragging","React","overlayRef","dragStartTime","dragEndTime","lastTimeDragPrevented","pointerStartY","drawerRef","initialViewportHeight","usePreventScroll","getScale","onPress","event","shouldDrag","isDraggingDown","element","date","onMove","_a","draggedDistance","drawerHeight","absDraggedDistance","wrapper","percentageDragged","opacityValue","scaleValue","borderRadiusValue","translateYValue","onVisualViewportChange","_b","visualViewportHeight","diffFromInitial","offsetFromTop","closeDrawer","swipeAmount","id","resetDrawer","currentSwipeAmount","onRelease","y","timeTaken","distMoved","velocity","onAnimationStart","e","o","DrawerContext","Overlay","rest","ref","useDrawerContext","composedRef","useComposedRefs","Content","onOpenAutoFocus","onPointerDownOutside","Drawer"]}